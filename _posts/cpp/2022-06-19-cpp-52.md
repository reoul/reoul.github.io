---
title: "[C++] ì“°ë ˆë”©(Threading) ë¼ì´ë¸ŒëŸ¬ë¦¬" 

categories:
  - Cpp
tags:
  - [Programming]


toc: true                         # ëª©ì°¨
toc_sticky: true                  # ëª©ì°¨ ì‚¬ì´ë“œë°” ê³ ì •

published: true                   #ê¸€ ê³µê°œ ì—¬ë¶€(falseí•´ë„ ì£¼ì†Œë¡œ ì ‘ê·¼ ê°€ëŠ¥)

date:       2022-06-19T21:59:00+09:00
lastmod:    2022-06-19T21:59:00+09:00
---

<!-- description : 25ìì—ì„œ 160ì ì‚¬ì´ -->
ì´ ê¸€ì€ C++ì˜ ì“°ë ˆë”©(Threading) ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ê³µë¶€í•˜ê³  ì •ë¦¬í•œ ê¸€ì…ë‹ˆë‹¤.<br>
ì“°ë ˆë”© ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” osë§ˆë‹¤ ë‹¤ë¥´ê²Œ êµ¬í˜„í–ˆë˜ ë©€í‹°ì“°ë ˆë”©ì„ í†µí•©ì‹œí‚¨ ë¼ì´ë¸ŒëŸ¬ë¦¬ì´ë‹¤.
{: .notice--warning}

## ì“°ë ˆë”© ë¼ì´ë¸ŒëŸ¬ë¦¬
- í‘œì¤€ C++ ì“°ë ˆë“œ
- osë§ˆë‹¤ ë‹¤ë¥´ê²Œ êµ¬í˜„í–ˆë˜ ë©€í‹°ì“°ë ˆë”©ì„ í†µí•©ì‹œí‚¨ ë¼ì´ë¸ŒëŸ¬ë¦¬
- ì´ë™(move) ê°€ëŠ¥
- ë³µì‚¬ ë¶ˆê°€ëŠ¥

  ### std::thread ìƒì„±ì

  ```cpp
  thread() noexcept;

  template<class Function, class... Args>
  explicit thread(Function&& f, Args&&... args);

  thread(thread&& other) noexcept;
  ```

  - ìƒˆ ì“°ë ˆë“œ ê°œì²´ë¥¼ ë§Œë“ ë‹¤

  ```cpp
  std::thread emptyThread;
  std::thread printThread(PringMessage, 10);        // void PrintMessage(int count);

  std::thread movedThread(std::move(printThread));  // OK. printThreadëŠ” ë” ì´ìƒ ì“°ë ˆë“œê°€ ì•„ë‹˜
  ```

  ### std::thread::join()

  ```cpp
  void join();
  ```

  - ì“°ë ˆë“œ ê°œì²´ê°€ ëë‚  ë•Œê¹Œì§€ í˜„ì¬ ì“°ë ˆë“œë¥¼ ë©ˆì¶° ë†“ëŠ”ë‹¤
  - ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œ í›„ ì“°ë ˆë“œ ê°œì²´ë¥¼ ì•ˆì „í•˜ê²Œ ì†Œë©¸ì‹œí‚¬ ìˆ˜ ìˆìŒ

  ```cpp
  std::thread thread(PrintMessage);     // void PrintMessage() {};
  thread.join();
  ```
  
  ### std::thread::get_id()

  ```cpp
  std::thread::id get_id() const noexcept;
  ```

  - ì“°ë ˆë“œ IDë¥¼ ë°˜í™˜í•œë‹¤

  ```cpp
  std::thread thread(PrintMessage);     // void PrintMessage() {};
  std::thread::id threadID = thread.get_id();
  ```

  ### std::thread::detach()

  ```cpp
  void detach();
  ```

  - ì“°ë ˆë“œ ê°œì²´ì—ì„œ ì“°ë ˆë“œë¥¼ ë–¼ì–´ ë‚¸ë‹¤
  - ë–¼ì–´ì§„ ì“°ë ˆë“œëŠ” ë©”ì¸ ì“°ë ˆë“œì™€ ë¬´ê´€í•˜ê²Œ ë…ë¦½ì ìœ¼ë¡œ ì‹¤í–‰ë¨

  ```cpp
  std::thread thread(PrintMessage);     // void PrintMessage() {};
  thread.detach();
  ```
  
  ### std::thread::joinable()

  ```cpp
  bool joinable() const noexcept;
  ```

  - ì“°ë ˆë“œê°€ ì‹¤í–‰ ì¤‘ì¸ í™œì„± ì“°ë ˆë“œì¸ì§€ ì•„ë‹Œì§€ í™•ì¸í•œë‹¤

  ```cpp
  std::thread thread(PrintMessage);     // void PrintMessage() {};
  if(therad.joinable())
  {
    // ...
  }
  ```

  ### std::ref()

  ```cpp
  template<class T>
  std::reference_wrapper<T> ref(T& t) noexcept;
  ```

  - Tì˜ ì°¸ì¡°ë¥¼ ë‚´í¬í•œ reference_wrapper ê°œì²´ë¥¼ ë°˜í™˜í•œë‹¤
  - <functional> í—¤ë”ì— ì •ì˜ë¼ ìˆìŒ
    - <thread>ë¥¼ ì¸í´ë£¨ë“œí•˜ë©´, <functional>ì„ ì¸í´ë£¨ë“œí•  í•„ìš” ì—†ìŒ

  ```cpp
  // void Sum(const std::vector<int>& list, int& result);
  std::thread thread(Sum, list, std::ref(result));
  ```
  
  ### std::this_thread::sleep_for()

  ```cpp
  template<class Rep, class Period>
  void sleep_for(const std::chrono::duration<Rep, Period>& sleep_duration);
  ```

  - ìµœì†Œ sleep_durationë§Œí¼ì˜ ì‹œê°„ ë™ì•ˆ í˜„ì¬ ì“°ë ˆë“œì˜ ì‹¤í–‰ì„ ë©ˆì¶˜ë‹¤

  ```cpp
  std::this_thread::sleep_for(std::chrono::seconds(1));
  ```
  
  ### std::this_thread::yield()

  ```cpp
  void yield() noexcept;
  ```

  - sleepê³¼ ë¹„ìŠ·í•˜ë‚˜, sleepì´ ì“°ë ˆë“œë¥¼ ì¼ì‹œ ì •ì§€ ìƒíƒœë¡œ ë°”ê¾¸ëŠ” ë°˜ë©´, yiledëŠ” ê³„ì† ì‹¤í–‰ ëŒ€ê¸° ìƒíƒœ
  - sleep_for(std::chrono::seconds(0)) ëŒ€ì‹  yield()ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤
    - sleepê°™ì€ ê²½ìš° ì“°ë ˆë“œë¥¼ ë©ˆì¶”ê³  ë‹¤ì‹œ ê°€ë™í•˜ëŠ” ìˆœê°„ì— **ì˜¤ë²„í—¤ë“œê°€ ìƒê¸°ê³  ëŠë ¤ì§„ë‹¤**

  ```cpp
  std::this_thread::sleep_for(std::chrono::seconds(1));
  ```

  ### std::mutex ìƒì„±ì
  ```cpp
  1. constexpr mutex() noexcept;
  2. mutex(const mutex&) = delete;
  ```

  1. ë®¤í…ìŠ¤ë¥¼ ë§Œë“ ë‹¤
  2. ë³µì‚¬ ìƒì„±ìëŠ” delete ì²˜ë¦¬ë¨

  ```cpp
  std::mutex mutex;
  ```
  
  ### std::mutex::lock()
  ```cpp
  void lock();
  ```

  - ë®¤í…ìŠ¤ë¥¼ ì ê·¼ë‹¤
  - ë™ì¼í•œ ì“°ë ˆë“œì—ì„œ ë‘ ë²ˆ ì ê·¸ë©´ ë°ë“œë½(deadlock) ë°œìƒ
    - ê¼­ ê·¸ë ‡ê²Œ í•´ì•¼ ëœë‹¤ë©´, std::recursive_mutexë¥¼ ì‚¬ìš©

  ```cpp
  std::mutex mutex;

  mutex.lock();
  ```

  ### std::mutex::unlock()
  ```cpp
  void unlock();
  ```

  - ë®¤í…ìŠ¤ ì ê¸ˆì„ í‘¼ë‹¤
  - í˜„ì¬ ì“°ë ˆë“œì—ì„œ ì ê¸´ ì ì´ ì—†ì„ ë•Œì˜ í–‰ë™ì€ ì •ì˜ë˜ì§€ ì•ŠìŒ

  ```cpp
  std::mutex mutex;

  mutex.lock();
  mutex.unlock();
  ```

  ### std::scoped_lock()
  ```cpp
  template<class... MutexTypes>
  class scoped_lock;
  ```

  - ë§¤ê°œë³€ìˆ˜ë¡œ ì „ë‹¬ëœ ë®¤í…ìŠ¤(ë“¤)ì„ ë‚´í¬í•˜ëŠ” ê°œì²´ë¥¼ ë§Œë“¬
  - ê°œì²´ ìƒì„±ì‹œì— ë®¤í…ìŠ¤ë¥¼ ì ê·¸ê³  **ë²”ìœ„(scope)ë¥¼ ë²—ì–´ë‚˜ ì†Œë©¸ë  ë•Œ í’ˆ**
  - ë°ë“œë½ì„ ë°©ì§€
  - C++14ì˜ ê²½ìš°, std::lock_guardë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë‚˜ ì´ ë•ŒëŠ” ë®¤í…ìŠ¤ë¥¼ í•˜ë‚˜ë§Œ ì „ë‹¬ ê°€ëŠ¥

  ```cpp
  std::scoped_lock<std::mutex> lock(mutex);
  std::scoped_lock<std::mutex, std::mutex> locks(mutex1, mutex2);
  std::scoped_lock<std::mutex, std::mutex, std::mutex> locks(mutex1, mutex2, mutex3);
  ```

  ### std::condition_variable()
  - ì´ë²¤íŠ¸ ê°œì²´
  - ì‹ í˜¸ë¥¼ ë°›ì„ ë•Œê¹Œì§€ í˜„ì¬ ì“°ë ˆë“œì˜ ì‹¤í–‰ì„ ë©ˆì¶¤
  - notify_one(), notify_all()
    - ë©ˆì¶° ë†“ì€ ì“°ë ˆë“œ í•˜ë‚˜ ë˜ëŠ” ì „ë¶€ë¥¼ ë‹¤ì‹œ ì‹¤í–‰ì‹œí‚´
  - wait(), wait_for(), wait_until()
    - ì¡°ê±´ ë³€ìˆ˜ì˜ ì¡°ê±´ì„ ì¶©ì¡±ì‹œí‚¬ë•Œê¹Œì§€ ë˜ëŠ” ì¼ì • ì‹œê°„ ë™ì•ˆ í˜„ì¬ ì“°ë ˆë“œì˜ ì‹¤í–‰ì„ ë©ˆì¶¤
  - `std::unique_lock`ì„ ì‚¬ìš©í•´ì•¼ í•¨

  ### std::unique_lock
  - ê¸°ë³¸ì ìœ¼ë¡œ scoped lock
  - ìƒì„±ì‹œì— lockì„ ì ê·¸ì§€ ì•Šì„ ìˆ˜ë„ ìˆìŒ(ë‘ ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜ë¡œ `std::defer_lock`ì„ ì „ë‹¬í•  ê²ƒ)
  - `std::recursive_mutex`ì™€ í•¨ê»˜ ì¨ì„œ ì¬ê·€ì ìœ¼ë¡œ ì ê¸€ ìˆ˜ ìˆìŒ
  - ì¡°ê±´ ë³€ìˆ˜ì— ì“¸ ìˆ˜ ìˆëŠ” ìœ ì¼í•œ lock

  ```cpp
  std::scoped_lock<std::mutex> lock(mutex);
  std::scoped_lock<std::mutex, std::mutex> locks(mutex1, mutex2);
  std::scoped_lock<std::mutex, std::mutex, std::mutex> locks(mutex1, mutex2, mutex3);
  ```

  ### std::condition_variable::wait()

  ```cpp
  1. void wait(std::unique_lock<std::mutex>& lock);
  
  2. template<class Predicate>
  2. void wait(std::unique_lock<std::mutex>& lock, Predicate pred);
  ```

  - í˜„ì¬ ì“°ë ˆë“œ ë®¤í…ìŠ¤ì˜ ì ê¸ˆì„ í’€ê³  notify_one() ë˜ëŠ” notify_all()ì„ ê¸°ë‹¤ë¦°ë‹¤
  - ê¹¨ì–´ë‚˜ë©´, ë®¤í…ìŠ¤ë¥¼ ë‹¤ì‹œ ì ê·¼ë‹¤
  - ntiofy_xxx()ê°€ wait()ë³´ë‹¤ ë¨¼ì € í˜¸ì¶œë˜ë©´, í•´ë‹¹ ì“°ë ˆë“œëŠ” ì˜ì›íˆ ê¸°ë‹¤ë¦°ë‹¤

  - 2ë²ˆì§¸ ê²½ìš°
  - ì•„ë˜ì™€ ê°™ìŒ
    ```cpp
    while (!pred())
    {
        wait(lock);
    }
    ```
  - ë‘ê°€ì§€ ìš©ë„ë¡œ ì‚¬ìš©
    - ì˜ëª» ê¹¨ì–´ë‚  ìœ„í—˜ì„ ì¤„ì„
    - pred()ëŠ” ì ê¸´ ë‘ ì“°ë ˆë“œ ëª¨ë‘ì—ì„œ ì ‘ê·¼í•  ìˆ˜ ìˆëŠ” bool ë³€ìˆ˜ì˜ ì—­í• ì„ í•¨

  - lockë§Œ ì“°ëŠ” ê²ƒì€ ì¶©ë¶„í•˜ì§€ ì•ŠìŒ
  ```cpp
  sEvent.wait(lock);
  ```
  - ì¡°ê±´ë³€ìˆ˜ê°€ ì‹ í˜¸(signal)ì„ ë°›ê¸° ì „ì— ëŒ€ê¸° ìƒíƒœì— ë“¤ì–´ê°€ëŠ” ê²ƒì„ **ë³´ì¥í•  ìˆ˜ ì—†ë‹¤ë©´ í•­ìƒ bool ì¡°ê±´ê³¼ lockì„ ê°™ì´ ì‚¬ìš©í•  ê²ƒ**
  ```cpp
  sEvent.wait(lock, [] { return !sQueue.empty(); });
  ```

<br>

## ì°¸ì¡°
[í¬íì•„ì¹´ë°ë¯¸ C++ ì–¸ë§¤ë‹ˆì§€ë“œ í”„ë¡œê·¸ë˜ë°](https://pocu-ko.teachable.com/p/comp3200)

***
<br>

    ğŸ’» ì—´ì‹¬íˆ ê³µë¶€í•´ì„œ ì‘ì„± ì¤‘ì´ë‹ˆ ì˜¤ë¥˜ë‚˜ í‹€ë¦° ë¶€ë¶„ì´ ìˆì„ ê²½ìš° 
      ì–¸ì œë“ ì§€ ëŒ“ê¸€ í˜¹ì€ ë©”ì¼ë¡œ ì•Œë ¤ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤! ğŸ˜¸


[ë§¨ ìœ„ë¡œ ì´ë™í•˜ê¸°](#){: .btn .btn--primary }{: .align-right}