---
title: "[Effective C++] 챕터 2 : 생성자, 소멸자 및 대입 연산자" 

categories:
  - Effective C++
tags:
  - [Effective C++, Book Summary]
# 태그는 무조건 2개 이상(1개면 글이 안보임)

toc: true
toc_sticky: true
#목차 생성 여부

published: true
#글 공개 여부(false해도 주소로 접근 가능)

date:       2022-07-21T18:34:00+09:00
lastmod:    2022-11-07T03:00:00+09:00
---

이 글은 스콧 마이어스님의 책 Effective C++의 챕터 2을 읽고 정리한 글입니다
{: .notice--warning}

<br>

## 📌 항목 5: C++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자

- 복사 생성자, 복사 대입 연산자, 소멸자는 직접 선언해 넣지 않으면 컴파일러가 저절로 선언해 준다
- 생성자조차도 선언되어 있지 않으면 역시 컴파일러가 대신 기본 생성자를 선언해 놓는다
- 소멸자는 이 클래스가 상속한 기본 클래스의 소멸자가 가상 소멸자로 되어 있지 않으면 역시 **비가상 소멸자로 만들어 진다**
- 참조자나 상수같은 경우 대입이 안되기 때문에 직접 복사 대입 연산자를 정의해주어야 한다
- 복사 대입 연산자를 `private`로 선언한 기본 클래스로부터 파생된 클래스의 경우, 이 클래스는 암시적 복사 대입 연산자를 가질 수 없습니다
- 컴파일러는 경우에 따라 클래스에 대해 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자를 암시적으로 만들어 놓을 수 있습니다

<br>

## 📌 항목 6: 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자

- 복사 생성자와 복사 대입 연산자를 `private` 멤버로 선언하면 외부로부터의 호출을 차단할 수 있습니다
- `private` 멤버 함수는 그 클래스의 멤버 함수 및 프렌드 함수가 호출할 수 있기 때문에 '**정의(define)**'를 하지 않으면 된다
  - 정의되지 않는 함수를 누군가가 실수로 호출하려 했다면 분명히 링크 시점에 에러를 보게 된다
- 복사 생성자와 복사 대입 연산자를 `private`로 선언하되, 이것을 별도의 기본 클래스에 넣고 이것으로부터 파생클래스를 만들어 깔끔하게 할 수도 있다

```cpp
class Uncopyable {
protected:
    Uncopyable() {}                                 // 생성과 소멸을
    ~Uncopyable() {}                                // 허용합니다
private:
    Uncopyable(const Uncopyable&);                  // 하지만 복사 방지
    Uncopyable& operators=(const Uncopyable&);
};

class HomeForSale : private Uncopyable {            // 복사 생성자, 복사 대입 연산자도 선언되지 않습니다
    ...
};
```

<br>

## 📌 항목 7: 다형성을 가진 기본 클래스에는 소멸자를 반드시 가상 소멸자로 선언하자

- C++ 규정에 의하면, 기본 클래스 포인터를 통해 파생 클래스 객체가 삭제될 때 그 기본 클래스에 비가상 소멸자가 들어 이씅면 프로그램 동작은 **미정의 사항**이라고 되어 있습니다
  - 대개 그 객체의 파생 클래스 부분이 소멸되지 않게 된다
- 결국 **메모리 누수**로 이어질 수 있다
- 기본 클래스에 가상 소멸자를 정의하면 해당 문제는 해결된다
- 가상 함수를 하나라도 가진 클래스는 가상 소멸자를 가져야 하는 게 대부분 맞습니다
- vptr(가상 함수 테이블 포인터 virtual table pointer)은 가상 함수의 주소, 즉 포인터들의 배열을 가리키고 있으며 가상 함수 테이블 포인터의 배열은 vtbl(가상 함수 테이블 virtual table)이라고 불린다
- 가상 함수를 하나라도 갖고 있는 클래스는 반드시 그와 관련된 vtbl을 갖고 있습니다
- 실제 함수는 그 객체의 vptr이 가리키는 vtbl에 따라 결정됩니다
- Point 클래스에 **가상 함수가 들어가게 되면 Point 타입 객체의 크기가 커진다**
- 어느 경우를 막론하고 소멸자를 전부 `virtual`로 선언하는 일은 `virtual`로 절대 선언하지 않는 것만큼이나 편찮은 마인드입니다
- 가상 소멸자를 선언하는 것은 그 클래스에 **가상 함수가 하나라도 있는 경우**에만 한정하세요
- 추상 클래스로 만들고 싶은 클래스에 순수 가상 소멸자를 선언한다
- 소멸자가 동작하는 순서는 상속 계통 구조에서 가장 말단에 있는 파생 클래스의 소멸자가 호출되는 것을 시작으로, 기본 클래스 쪽으로 거쳐 올라가면서 각 기본 클래스의 소멸자가 하나씩 호출됩니다
  - 컴파일러는 ~AWOV의 호출 코드를 만들기 위해 파생 클래스의 소멸자를 사용할 것이므로, 잊지 말고 이 함수의 본문을 준비해 두어야 한다
  - 만약 이 부분을 잊으면 링커 에러를 보게 된다
  - 그래서 순수 가상 소멸자의 정의를 두지 않으면 안된다

<br>

## 📌 항목 8: 예외가 소멸자를 떠나지 못하도록 붙들어 놓자

- 소멸자로부터 예외가 터져 나가는 경우를 C++ 언어에서 막는 것은 아니지만, 실제 상황을 들춰보면 확실히 우리가 막을 수밖에 없는 것 같습니다
- C++는 예외를 내보내는 소멸자를 좋아하지 않는다
- 예외를 던지는 소멸자는 곧 '걱정거리'를 의미한다. 걱정거리를 피하는 두 가지 방법이 있다.
  - 예외가 발생하는 프로그램을 바로 끝낸다. 대개 abort를 호출한다.
    - 객체 소멸이 진행되다가 에러가 발생한 후에 프로그램 실행을 계속할 수 없는 상황이라면 꽤 괜찮은 선택이다
    - 예외를 그래로 흘려 내보냈다가 정의되지 않은 동작에까지 이를 수 있다면, 그런 불상사를 막는다는 의미에서 어느 정도 장점도 있다
  - 호출한 곳에서 일어난 예외를 삼켜 버린다
    - 대부분의 경우에서 예외 삼키기는 그리 좋은 발상은 아닙니다
    - 중요한 정보가 묻혀 버리기 때문입니다
    - 하지만 때에 따라서는 불완전한 프로그램 종료 혹은 미정의 동작으로 인해 입는 위험을 감수하는 것보다 그냥 예외를 먹어 버린는 게 나을 수도 있다
    - 단, '예외 삼키기'를 선택한 것이 제대로 빛을 보려면, 발생한 예외를 그냥 무시한 뒤라도 프로그램이 신뢰성 있게 실행을 지속할 수 있어야 한다
- 어느 쪽을 택하든 특별히 좋은 건 없어 보인다
- 둘 다 문제점이 있기 때문이다
- 중요한 것은 close가 최초로 예외를 던지게 된 요인에 대해 프로그램이 어떤 조치를 취할 수 있는가인데, 이런 부분에 대한 대책이 전무한 상태이니까요
- DBConn에서 close함수를 직접 제공하게 하면 이 함수의 실행 중에 발생하는 예외를 사용자가 직접 처리할 수 있을 것입니다
- 어떤 동작이 예외를 일으키면서 실패할 가능성이 있고 또 그 예외를 처리해야 할 필요가 있다면, 그 예외는 **소멸자가 아닌 다른 함수에서 비롯된 것이어야 한다**는 것이 포인트이다
- 사용자가 호출할 수 있는 close 함수를 두긴 했지만 부담을 떠넘기는 모양새가 아닙니다
- 사용자에게 에러를 처리할 수 있는 기회를 주는 것이죠

<br>

## 📌 항목 9: 객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말자

- 생성자는 파생 클래스 객체가 생성될 때 그 객체의 기본 클래스 부분이 파생 클래스 부분보다 먼저 호출된다
- 만약 기본 클래스 생성자에서 logTransaction 함수를 호출하면 파생 클래스의 logTransaction 함수가 아닌 기본 클래스의 logTransaction 함수가 호출되게 된다
- 기본 클래스의 생성자가 호출될 동안에는, 가상 함수는 절대로 파생 클래스 쪽으로 내려가지 않는다
- 그 대신, **객체 자신이 기본 클래스 타입인 것처럼 동작**한다
- 기본 클래스 생성자가 돌아가고 있을 시점에 **파생 클래스 데이터 멤버는 아직 초기화된 상태가 아니라는 것**이 핵심이다
- 아직 초기화되지 않는 데이터 멤버를 건드리면 '미정의 동작'이 발생될 수 있다
- 이렇듯 어떤 객체의 초기화되지 않은 영역을 건드린다는 것은 치명적인 위험을 내포하기 때문에, C++는 이런 실수조차 하지 못하도록 막은 것이다
- 파생 클래스 객체의 기본 클래스 부분이 생성되는 동안은, 그 객체의 타입은 바로 기본 클래스이다
- 호출되는 가상 함수는 모두 기본 클래스의 것으로 결정될 뿐만 아니라, 런타임 타입 정보를 사용하는 언어 요소(dynamic_cast나 typeid 같은 것)를 사용한다고 해도 이 순간엔 모두 기본 클래스 타입의 객체로 취급된다
- **객체가 소멸될 때도 똑같이 생각하면 된다**
- 해결법은 비가상 멤버 함수로 바꾸는 것이다

<br>

## 📌 항목 10: 대입 연산자는 *this의 참조자를 반환하게 하자

- 대입 연산이 가진 또 하나의 재미있는 특성은 바로 우측 연관 연산이라는 점이다
- 대입 연산이 사슬처럼 엮이려면 대입 연ㅅ나자가 좌변 인자에 대한 참조자를 반환하도록 구현되어 있을 것이다
- 이런 구현은 일종의 관례인데, 여러분 나름대로 만드는 클래스에 대입 연산자가 혹시 들어간다면 여러분도 이 관례를 지키는 것이 좋다
- 이 관례는 모든 기본제공 타입들이 따르고 있을 뿐만 아니라 표준 라이브러리에 속한 모든 타입에서도 따르고 있다

<br>

## 📌 항목 11: operator=에서는 자기대입에 대한 처리가 빠지지 안도록 하자

- 자기대입`self assignment`이란, 어떤 객체가 **자기 자신**에 대해 대입 연산자를 적용하는 것을 말한다
- 같은 타입으로 만들어진 객체 여러개를 참조자 혹은 포인터로 물어 놓고 동작하는 코드를 작성할 때는 같은 객체가 사용될 가능성을 고려하는 것이 일반적으로 바람직한 자세가 되겠다
- 어쩌다 보면 자원을 사용하기 전에 덜컥 해제해 버릴수도 있을지 모릅니다
- 전통적인 해결방법은 operator=의 첫머리에서 일치성 검사`identity test`를 통해 자기대입을 점검하는 것이다
- 만약 **delete** 하고 **동적할당에서 예외가 터지게 되면** 결국 객체는 삭제된 포인터를 껴안고 홀로 남고 만다
- 포인터를 무턱대로 삭제하지 말고 이 포인터가 가르키는 객체를 복사한 직후에 삭제하면 깔끔히 해결될 것 같다
  ``` cpp
  Widget& Widget::operator=(const Widget& rhs)
  {
      Bitmap * pOrig = pb;          // 원래의 pb를 어딘가에 기억해 둡니다
      pb = new Bitmap(*rhs.pb);     // 다음, pb가 *pb의 사본을 가리키게 만듭니다
      delete pOrig;                 // 원래의 pb를 삭제합니다
  }
  ```
- 위 코드는 예외에서 안전합니다
- 'new Bitmap' 부분에서 예외가 발생하더라도 pb는 변경되지 않은 상태가 유지되기 때문이다
- 게다가 일치성 검사 같은 것이 없음에도 불구하고 이 코드는 자기대입 현상을 완벽히 처리하고 있다
- 다른 방법으로는 '복사 후 맞바꾸기`copy and swap`'라고 알려진 기법이 있다

<br>

## 📌 항목 12: 객체의 모든 부분을 빠짐없이 복사하자

- 복사 생성자나 복사 대입 연산자은 복사되지 않은 변수가 있더라도 **컴파일러는 알려주지 않는다**
- 또한 클래스 상속을 했을 때 파생 클래스에서 기본 클래스의 복사 생성자나 복사 대입 연산자를 **호출하지 않으면 부모 클래스는 복사되지 않는다**
- 객체의 복사 함수를 작성할 때 확인해야 할 사항 2가지
  - 해당 클래스의 데이터 멤버를 모두 복사하고
  - 이 클래스가 상속한 기본 클래스의 복사 함수도 꼬박꼬박 호출
- <u>클래스의 복사 함수 2개를 구현할 때, 한쪽을 이용해서 다른 쪽을 구현하려는 시도는 절대로 하지 마세요</u>
- 그 대신, 공통된 동작을 제 3의 함수에다 분리해 놓고 양쪽에서 이것을 호출하게 만들어서 해결합시다

<br>

***
<br>

    💻 열심히 공부해서 작성 중이니 오류나 틀린 부분이 있을 경우 
      언제든지 댓글 혹은 메일로 알려주시면 감사하겠습니다! 😸

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}